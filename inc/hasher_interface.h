#ifndef HASHER_INTERFACE_H
#define HASHER_INTERFACE_H

/* 
** A hasher interface is an interface allowing you to hash data (pointed to by data pointers)
** It allows you to hash with OR without a context
*/

#include<cutlery_stds.h>

typedef struct hasher_interface hasher_interface;
struct hasher_interface
{
	// context for the hasher
	const void* context;

	// the hash functions of the hasher
	union
	{
		// hash function to use when context == NULL
		cy_uint (*hash1)(const void* data);

		// hash function to use when context != NULL
		cy_uint (*hash2)(const void* context, const void* data);
	};
};

// you must use only this function, with the hasher, to avail the complete functionality of the hasher
// it returns the hash of the data
static inline cy_uint hash_with_hasher(const hasher_interface* hasher, const void* data)
{
	if(hasher->context == NULL)
		return hasher->hash1(data);
	else
		return hasher->hash2(hasher->context, data);
}

// You may use the macros below to initialize your custom hasher_interface
#define simple_hasher(hash_function_p)               ((const hasher_interface){.context = NULL,        .hash1 = (hash_function_p)})
#define contexted_hasher(context_p, hash_function_p) ((const hasher_interface){.context = (context_p), .hash2 = (hash_function_p)})

/*
**	There should be some times when your custom very simple hash function does not generate a random enough hash value
**	OR there is a linear relation ship between the hash value generated by you, giving you very bad distribution of objects over the buckets of the hash table
**	To mitigate this the below hash_randomizer is provided to be applied to your output hash value to effectively randomize it
*/
/*
** This could be used to hash, liner relationsships generated for aligned pointers OR page_id for disk accessed that can be multiples of bytes in page OR blocks in page OR some other simple linear increments
*/
static inline cy_uint hash_randomizer(cy_uint input)
{
	unsigned long long int x = input;
	x ^= x >> 33ULL;
	x *= 0x9E3779B97F4A7C15ULL;
	x ^= x >> 29ULL;
	x *= 0xC4CEB9FE1A85EC53ULL;
	x ^= x >> 33ULL;
	return x;
}

#endif