(building new simple data structures)
 STAGE - 1
  * BST
	* find_all_in_range(bst, data_small, data_large, max_result_count, result_arraylist)
	 	-> find all (or maximum being max_result_count number of) elements from bst that are greater than or equal to data_small and lesser than or equal to data_large, and them into result_arraylist
	 	->  if data_small == NULL (or -infinity), 
	 			then we will find all elements that are lesser than or equals to data_large; 
	 		else if data_large == NULL (or +infinity),
	 			then we will find all elements that are greater than or equals to data_small;
		-> Also write for_each_in_range(bst, data_small, data_large, max_result_count, void (*result_accumulator)(const void* data, const void* additional_params), void* additional_params);
 	* iterative (for loop) approach for in-order, pre-order and post-order traversals.
 * ARRAY
	* radix_sort function for array based on a hash_function (instead of a compare function) given by the user in function params.
	* include heap_sort and quick_sort aswell.
 * DSTRING
 	* addition to dstring => distance formulas Levenshtein, Hamming, Lee, Jaro Winkler distance of strings in a separate src file dstring_distance.c.
 	* segregate sstring contains function, dstring_substring.c.

(long term implementation for all graph algorithms)
 STAGE - 2
 * use graph descriptor interface to build graph algorithms like :
       * dfs (iterative only (not recursive) with Cutlery stack)
       * bfs (iterative only with Cutlery queue)
       * bellmanford
       * dijkstra
       * floydwarshall
       * A*-star
       * minimum spanning tree
        etc (more will be added)

-----------------------------------------------------------------------------------------
--------------------------- RELEASE 1.0 -------------------------------------------------
-----------------------------------------------------------------------------------------

(fix print functions)
 STAGE - 3
 * convert all print functions to dstring based serializers using snprintf_dstring(), also with debug_print and tab_count as input parameters -> get rid of <stdio.h>

(fix memmory allocation user's interface with Cutlery library)
 STAGE - 4
 * provide expand_array_addional_size functions to expand array and other dependent datastructures to control memory allocation in a more controlled and flexible way
 * provide a function to set all cutlery data structure's container pointer memory pointer to static memory or to pre-allocated memory locations
 * remove pointer to memory allocator and default to a global void pointer allocator, like we did to dstring. Since all Cutlery containers (except dstring) allocate and use only void pointers, there is no reason from different allocators, except for covering very specific use cases (which though not discussed, we still may not be willing to miss; SO keeping this pointer as is for now).

(optimize resize_hashmap function)
STAGE - 5
 * for ELEMENTS_AS_LINKEDLIST and ELEMENTS_AS_*_BST we could use linkedlist queue to save on the additional memory (taken by the "queue q" structure)