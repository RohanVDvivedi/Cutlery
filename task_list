1. Miscelaneous tasks and string/byte array tasks

COMMON to all datastructures tasks
 * add remove all functionality for all data structures
 * change total_size to capacity for all cutlery containers

DSTRING tasks
 * implement dstring_get_char function returning a character at a given index
 * provide an ability to store the dstring on the stack itself when the strlen(string) < sizeof(dstring) i.e. use dstring as a union of char[] and dstring (current definition)
 * implement rabin krap and boyer moore substring comparison algorithm, use flat map and flat array for its tables, also use rabin krap hash function as summation of (index * string[index]) for all characters of the string to encapsulate position information of the string in the hash.
 * provide a better interface for selecting between all the 4 substring matching algorithms
 * provide a struct to access values in multidimensional array
 * provide methods to get next multiple of a number and a previous multiple of a number and mul, div and mod with powers of 2

BYTESTREAM tasks (NEW DATASTRUCTURE)
 * implement and add a stream buffer interface that acts as a queue of strings or serialized objects, this can be used for implementation of network stacks, server request response buffering, parsers and compression algorithms

RADIX_TREE tasks (NEW DATASTRUCTURE)
 * implement a radix tree data structure i.e. a trie data structure that is defined as
struct trie_node
{
    dstring partial_string;
    int prefix_count; // total number of strings in the complete trie structure that have the prefic ending at partial string
    void* value;
    hashmap children; <K,V> => <trie_node.partial_string[0],trie_node>;
};
 * implement insert, search and remove operation to be noted a trie_node can not be deleted as long as it has either of value or any of the children

CUTLERY_STDS tasks
 * refactor memmove to not cross provided address boundaries
 * in memory allocator interface replace new_size from int to int* allowing the allocator to return more memory than what we asked for

SORT & SEARCH tasks
 * provide functionality for insertion point fnding in the array_search_sort source file

2. Add new datastructure types tasks

HEAP tasks (NEW DATASTRUCTURE inclusion)
 * implement a node based binomial heap and fibonacci heap (implement them as an embedded node based data structure like linked_list and bst, such that this embedded node consists of leftmost_child, parent and right_sibling pointers only), rename heap to binary heap
 * build an abstraction layer over all the three heaps and name it heap and make all methods available from it

BST tasks (NEW DATASTRUCTURE inclusion)
 * provide implementation for splay trees, Treap, AA etc in bst (* not yet decided, if it will be implemented)
 * point parent of root node of the bst to some thing other than null to identify a new_node from a single node bst root node

LINKEDLIST tasks (NEW DATASTRUCTURE inclusion)
 * provide implementation for singly linked list also, and rename the linkedlist to doubly circular linked list, provide a single linkedlist interface to access both the linked list just like heap
 * ll_node must be a union of sll_node and dcll_node
 * use singly linked list to replace linked lists used in hashmap and binomial/fibonacci heap implementation
 * add functionality to append 2 linkedlists and make the 2nd linked list contain 0 elements

3. Competely new datastructure tasks

RANGE QUERY ON INT/UINT ARRAY DATASTRUCTURE tasks
 * use int or unsigned int for below functionality yet to decide on that
 * use flatmap or direct array for the below functionality yet to decide on that as well
 * implement segment tree for any array A and function f such that
    f[i ... k] = f( f(A[i ... j-1]) , f(A[j ... k]) )
    function f must be of signature int f(int a, int b)
    and also must follow properties like
     * f(a,b) = f(b,a)
     * f(a,f(b,c)) = f(f(a,b),c) = f(f(a,c),b)
     * if function f has to be applied on N integers to form a final result R, then the order in which we apply f must not alter the result R
    examples of such functions are min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor, lcm and hcf etc

    * for an array of size n => we need a segment tree with ( 2 * n - 1) number of nodes (managed as an array of completely filled binary tree)
    * for a tree with parent p index -> its children have indices 2 * p + 1 and 2 * p + 2 just like the heap array
    * for any child with index c -> its parent is at ( (c - 1) / 2 ) index
    * if the range of a node is (l ,h) this means the integer value at this node = f(A[l...h]) (incuding l and h)
    * if the range of the parent is (l, h), then its childred have ranges (l, m-1) and (m, h)
      * here m = largest power of 2 lesser than h - l + 1
    * the range of root node is always is (0, n-1) for n number of elements

    * segment tree must be coded using iterative approach

 * implement fenwick tree => for addition, product(multiplication), bitwise-xor => the functions for which their inverse exists
 * implement sparse table => max, min, lcm, hcf => the functions for which f(a,b,c,d,e) = f(f(a,b,c), f(b,c,d,e))

FLAT datastructure tasks (NEW DATASTRUCTURE)
 * implement flat_array and flat_map (using robinhood hashing) that use void* to array of structs instead of void** to array of pointers to structs
 * check and re evaluate what all algorithms can be moved to using flat array and flat map for better cache utilization and replace them
 * provide reasons explicitly for all such decisions, do not replace to flat map or flat array while handling user provided structures

PROBABLISTIC datastructure tasks (NEW DATASTRUCTURE)
 * implement bloom filter, build it with approximate unique count
 * implement count min sketch, alternatives like INCREMENT_ALL vs INCREMENT_MIN_ONLY

4. Optimization tasks

SORT optimizations tasks
 * heap sort to directly utilize the memory area of the array
 * quick sort refactor to use itertion instead of recursion

HASHMAP optimization tasks
 * modify hashmap's % function to something of the sort of bitwise operation to speed it instead of hash % N use something like bitwise(x, N) => [0,N) range