1. Tasks picked

DSTREAM (new data structure)
	** without external locking this data-structure is useless - add this in the header as first comment
	** here, the capacity must be larger than the largest data that you may try to write with type = ACCEPT_ALL_OR_NONE
	void initialize_dstream(dstream* strm, unsigned int capacity);
	** here operation_type = ACCEPT_ALL_OR_NONE OR ACCEPT_PARTIAL
	unsinged int write_to_dstream(dstream* strm, const void* data, unsigned int data_size, operation_type type);
	unsigned int read_from_dstream(dstream* strm, void* data, unsigned int data_size, operation_type type);
	int is_empty_dstream(const dstream* strm);
	int is_full_dstream(const dstream* strm);
  // additional functionalities
  unsinged int push_back_dstream(dstream* strm, const void* data, unsigned int data_size, operation_type type);
  unsinged int push_front_dstream(dstream* strm, const void* data, unsigned int data_size, operation_type type);
  unsigned int pop_back_dstream(dstream* strm, void* data, unsigned int data_size, operation_type type);
  unsigned int pop_front_dstream(dstream* strm, void* data, unsigned int data_size, operation_type type);
  write_to_dstream == push_back_dstream
  read_from_dstream == pop_front_dstream
  int expand_dstream(dstream* strm);
  int resize_dstream(dstream* strm, unsigned int new_capacity);
	void close_dstream_for_writer(dstream* strm);     // after this call all write_* calls will return 0 immediately, i.e. failing
	void close_dstream_for_reader(dstream* strm);     // after this call all write calls will return data_size i.e. all success; and all read calls will fail
	int is_closed_for_writer(const dstream* strm);
	int is_closed_for_reader(const dstream* strm);
	void deinitialize_dstream();                      // calls close on both the sides of dstream

2. Add new datastructure types tasks (*future)

RADIX_TREE tasks (NEW DATASTRUCTURE)
 * implement a radix tree data structure i.e. a trie data structure that is defined as
struct trie_node
{
    dstring partial_string;
    int prefix_count; // total number of strings in the complete trie structure that have the prefix (or are equal-to) of partial_string
    void* value;
    hashmap children; <K,V> => <trie_node.partial_string[0],trie_node>;
};
 * implement insert, search and remove operation to be noted a trie_node can not be deleted as long as it has either of value or any of the children

HEAP tasks (NEW DATASTRUCTURE inclusion)
 * implement a node based binomial heap and fibonacci heap and abstract them over the fastheap datastructure in cutlery, implemented as enums like FIBONACCI_HEAP and BINOMIAL_HEAP

DSTRING tasks
 * implement boyer moore substring finding algorithm (and Aho corasick algorithm)

BST tasks (NEW DATASTRUCTURE inclusion)
 * provide implementation for splay trees, Treap, AA etc in bst (* not yet decided, if it will be implemented)
 * add unsigned int subtree_size (==0 if node is not in any bst) giving the number of nodes in sub tree rooted at the given node 
   * to provide functionality to get nth smallest or largest in the bst
   * it will also get number of elements greater than x and lesser than x, OR get_element_count in bst and get_subtree_element_count (internal function).
   * changes only required to subtree_size in rotation, exchange_positions and insert_node_in_bst (make subtree_size = 1) and remove_node_from_bst (make subtree_size = 0) functionality.
 * provide an iterator for bst.

3. Competely new datastructure tasks (*future)

RANGE QUERY ON INT/UINT ARRAY DATASTRUCTURE tasks
 * use int or unsigned int for below functionality and implement their itrative approaches only
 * access methods must be insert, update, find_range
 * implement segment tree => for min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor, lcm and hcf
 * implement fenwick tree => for addition, product(multiplication), bitwise-xor => the functions for which their inverse exists
 * implement sparse table => max, min, lcm, hcf => the functions for which f(a,b,c,d,e) = f(f(a,b,c), f(b,c,d,e))
