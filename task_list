 * implement segment tree for any array A and function f such that
 	f[i ... k] = f( f(A[i ... j-1]) , f(A[j ... k]) )
 	function f must be of signature int f(int a, int b)
 	and also must follow properties like
 	 * f(a,b) = f(b,a)
 	 * f(a,f(b,c)) = f(f(a,b),c) = f(f(a,c),b)
 	 * if function f has to be applied on N integers to form a final result R, then the order in which we apply f must not alter the result R
 	examples of such functions are min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor etc

 	* for an array of size n => we need a segment tree with ( 2 * n - 1) number of nodes (managed as an array of completely filled binary tree)
 	* for a tree with parent p index -> its children have indices 2 * p + 1 and 2 * p + 2 just like the heap array
 	* for any child with index c -> its parent is at ( (c - 1) / 2 ) index
 	* if the range of a node is (l ,h) this means the integer value at this node = f(A[l...h]) (incuding l and h)
 	* if the range of the parent is (l, h), then its childred have ranges (l, m-1) and (m, h)
 	  * here m = largest power of 2 lesser than h - l + 1
 	* the range of root node is always is (0, n-1) for n number of elements

	* segment tree must be coded using iterative approach

 * additional functionality for bst
   * find_succeeding
   * find_preceeding
   * add test cases for this

 * refactor memmove to not cross provided address boundaries

 * refactor binary search to some thing like:
arr = [1,3,5,7,9,11,13,15,17,19,21]

find = 2
found_index = -1

l = 0
h = len(arr) - 1
if(arr[l] <= find and find <= arr[h]):
    while(l<=h):
        m = l + int((h-l)/2)
        print("l : " + str(l) + ", m : " + str(m) + ", h : " + str(h))
        if(arr[m] < find):
            # found_index = m
            l = m+1
        elif(arr[m] > find):
            # found_index = m
            h = m-1
        else:
            found_index = m
            break
    print("l : " + str(l) + ", h : " + str(h))


