1. Tasks picked

ARRAY
* union{const void** data_p_p; const void* data;}; for a array_capacity == 1, you do not need to call malloc
* use get_element/set_element everywhere, avoid using data[] operators directly

2. Add new datastructure types tasks (*future)

DSTRING tasks
 * implement boyer moore substring finding algorithm (and Aho corasick algorithm)

HEAP tasks (NEW DATASTRUCTURE inclusion)
 * implement a node based binomial heap and fibonacci heap and abstract them over the fastheap datastructure in cutlery, implemented as enums like FIBONACCI_HEAP and BINOMIAL_HEAP

BST tasks (NEW DATASTRUCTURE inclusion)
 * provide implementation for splay trees, Treap, AA etc in bst (* not yet decided, if it will be implemented)
 * add unsigned int subtree_size giving the number of nodes in sub tree rooted at the given node 
   * to provide functionality to get nth smallest or largest in the bst
   * this variable is 0 in a node that is not in bst.
   * changes only required to subtree_size in rotation, exchange_positions and insert (make subtree_size = 1) and delete (make subtree_size = 0) functionality.
   * it will also get number of elements greater than x and lesser than x, OR get_element_count in bst and get_subtree_element_count (internal function).
   * exists_in_bst -> this will allow us to know if a node is in any of the bst (if subtree_size == 0, means it does not exist in any of the bsts ever)
 * provide an iterator for bst.

RADIX_TREE tasks (NEW DATASTRUCTURE)
 * implement a radix tree data structure i.e. a trie data structure that is defined as
struct trie_node
{
    dstring partial_string;
    int prefix_count; // total number of strings in the complete trie structure that have the prefix (or are equal-to) of partial_string
    void* value;
    hashmap children; <K,V> => <trie_node.partial_string[0],trie_node>;
};
 * implement insert, search and remove operation to be noted a trie_node can not be deleted as long as it has either of value or any of the children

3. Competely new datastructure tasks (*future)
UNION FIND datastructure
 * implement union find data structure, consisting of embedded nodes.
 * each embedded node consists of parent*, rank and sub_tree_size for each embedded node, a reset function sets all of them to 0s
 * find will directly attach the node to its parent, union merges based on rank or subtree size
 * and only for root->parent == NULL. set/union identifier is the pointer to the root element, we call this unification_id, which can be compared to check if two elements are in same group. typedef void* unification_id
 * no collection will be used to maintain all the unions, we dont care about

RANGE QUERY ON INT/UINT ARRAY DATASTRUCTURE tasks
 * use int or unsigned int for below functionality and implement their itrative approaches only
 * access methods must be insert, update, find_range
 * implement segment tree => for min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor, lcm and hcf
 * implement fenwick tree => for addition, product(multiplication), bitwise-xor => the functions for which their inverse exists
 * implement sparse table => max, min, lcm, hcf => the functions for which f(a,b,c,d,e) = f(f(a,b,c), f(b,c,d,e))

FLAT datastructure tasks (NEW DATASTRUCTURE)
 * implement flat_array and flat_map (using robinhood hashing) that use void* to array of structs instead of void** to array of pointers to structs
 * check and re evaluate what all algorithms can be moved to using flat array and flat map for better cache utilization and replace them
 * provide reasons explicitly for all such decisions, do not replace to flat map or flat array while handling user provided structures

PROBABLISTIC datastructure tasks (NEW DATASTRUCTURE)
 * implement bloom filter, build it with approximate unique count
 * implement count min sketch, with alternatives like INCREMENT_ALL vs INCREMENT_MIN_ONLY
