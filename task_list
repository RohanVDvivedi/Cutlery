1. Miscelaneous tasks and string/byte array tasks (*now)

COMMON to all datastructures tasks
 * reserve_capacity_* to resize the array to atleast a specific size, and support it in heap, arraylist (stack and queue)

2. Add new datastructure types tasks (*future)

HEAP tasks (NEW DATASTRUCTURE inclusion)
 * implement a node based binomial heap and fibonacci heap (implement them as an embedded node based data structure like linked_list and bst, such that this embedded node consists of leftmost_child, parent and right_sibling pointers only), rename heap to binary heap
 * build an abstraction layer over all the three heaps and name it heap and make all methods available from it

BST tasks (NEW DATASTRUCTURE inclusion)
 * provide implementation for splay trees, Treap, AA etc in bst (* not yet decided, if it will be implemented)
 * point parent of root node of the bst to some thing other than null to identify a new_node from a single node bst root node

LINKEDLIST tasks (NEW DATASTRUCTURE inclusion)
 * provide implementation for singly linked list also, and rename the linkedlist to doubly circular linked list, provide a single linkedlist interface to access both the linked list (singly and doubly circular)
 * ll_node must be a union of sll_node and dcll_node
 * use singly linked list to replace linked lists used in hashmap and binomial/fibonacci heap implementation
 * also implement stack and queue using singly linkedlist

3. Competely new datastructure tasks (*future)

RADIX_TREE tasks (NEW DATASTRUCTURE)
 * implement a radix tree data structure i.e. a trie data structure that is defined as
struct trie_node
{
    dstring partial_string;
    int prefix_count; // total number of strings in the complete trie structure that have the prefic ending at partial string
    void* value;
    hashmap children; <K,V> => <trie_node.partial_string[0],trie_node>;
};
 * implement insert, search and remove operation to be noted a trie_node can not be deleted as long as it has either of value or any of the children

RANGE QUERY ON INT/UINT ARRAY DATASTRUCTURE tasks
 * use int or unsigned int for below functionality and implement their itrative approaches only
 * access methods must be insert, update, find_range
 * implement segment tree => for min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor, lcm and hcf
 * implement fenwick tree => for addition, product(multiplication), bitwise-xor => the functions for which their inverse exists
 * implement sparse table => max, min, lcm, hcf => the functions for which f(a,b,c,d,e) = f(f(a,b,c), f(b,c,d,e))

FLAT datastructure tasks (NEW DATASTRUCTURE)
 * implement flat_array and flat_map (using robinhood hashing) that use void* to array of structs instead of void** to array of pointers to structs
 * check and re evaluate what all algorithms can be moved to using flat array and flat map for better cache utilization and replace them
 * provide reasons explicitly for all such decisions, do not replace to flat map or flat array while handling user provided structures

PROBABLISTIC datastructure tasks (NEW DATASTRUCTURE)
 * implement bloom filter, build it with approximate unique count
 * implement count min sketch, with alternatives like INCREMENT_ALL vs INCREMENT_MIN_ONLY

4. SPECIFIC no direct use case as of now, tasks (*later - procrastinated due to their way lower priority)

CUTLERY_STDS tasks
 * in memory allocator interface replace new_size from unsigned int to unsigned int* allowing the allocator to return more memory than what we asked for

DSTRING tasks
 * implement boyer moore substring finding algorithm (and Aho corasick algorithm)

5. Optimization/correctness in indexing tasks (*later - procrastinated due to their way lower priority)

COMMON to all datastructures tasks
 * implement strict unsigned int range indexing for all cutlery datastructures
 * refactor memory_set, memmory_move and memory_compare to not cross provided address boundaries