 * implement segment tree for any array A and function f such that
 	f[i ... k] = f( f(A[i ... j-1]) , f(A[j ... k]) )
 	function f must be of signature int f(int a, int b)
 	and also must follow properties like
 	 * f(a,b) = f(b,a)
 	 * f(a,f(b,c)) = f(f(a,b),c) = f(f(a,c),b)
 	 * if function f has to be applied on N integers to form a final result R, then the order in which we apply f must not alter the result R
 	examples of such functions are min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor, lcm and hcf etc

 	* for an array of size n => we need a segment tree with ( 2 * n - 1) number of nodes (managed as an array of completely filled binary tree)
 	* for a tree with parent p index -> its children have indices 2 * p + 1 and 2 * p + 2 just like the heap array
 	* for any child with index c -> its parent is at ( (c - 1) / 2 ) index
 	* if the range of a node is (l ,h) this means the integer value at this node = f(A[l...h]) (incuding l and h)
 	* if the range of the parent is (l, h), then its childred have ranges (l, m-1) and (m, h)
 	  * here m = largest power of 2 lesser than h - l + 1
 	* the range of root node is always is (0, n-1) for n number of elements

	* segment tree must be coded using iterative approach

 * additional functionality for bst
   * find_succeeding
   * find_preceeding
   * add test cases for this

 * refactor memmove to not cross provided address boundaries

 * refactor binary search to some thing like:
 * make binary search and linear search functions take a flag parameter to return either first or last occurrence of the given element.
arr = [1,3,9,11,13,13,15,15,15,19,19,19,21,23,33,55]

find = 7

lesser_index = -1
found_index = -1
greater_index = -1

l = 0
h = len(arr) - 1
if(arr[l] <= find and find <= arr[h]):
    while(l<=h):
        m = l + int((h-l)/2)
        print("l : " + str(l) + ", m : " + str(m) + ", h : " + str(h))
        if(arr[m] < find):
            lesser_index = m
            l = m+1
        elif(arr[m] > find):
            greater_index = m
            h = m-1
        else:
            found_index = m
            break
    print("l : " + str(l) + ", h : " + str(h))
else:
    if(find < arr[l]):
        greater_index = l
    elif(arr[h] < find):
        lesser_index = h

if(found_index == -1 and lesser_index != -1):
    print("lesser - " + str(lesser_index) + " - " + str(arr[lesser_index]))
if(found_index != -1):
    print("found - " + str(found_index) + " - " + str(arr[found_index]))
if(found_index == -1 and greater_index != -1):
    print("greater - " + str(greater_index) + " - " + str(arr[greater_index]))

 * is_reordering_required method let compare function handle null values, and add comments accordingly
 * in bubble down method add more comments, and initialize new parent index to index instead of -1
 * refactor heap to reduce redundant bracket scopes
 * bug in remove function as we may require to bubble up or down right until common ancestor
   * and do not bubble up or down if heap element count is 0 after removal, i.e. when heap is empty bubble up and bubble down must be a nop
 * add a macro to check if root of the tree or leaf of the tree will be help full to bound array indices
 * try converting parent and child index calculations to macros instead of functions
 * bug in heapify_at functionality, check parent_index and childindex ranges before bubble up or bubble down
 * add insert_all method in heap implementation to build the heap from a given array, use the bottom up bubble down implementation to do this in O(n) time
 * also update heap_sort method to use this implementation for faster sort although this wont decrease time complexity of the heap sort function

 * provide get first occurence and get last occurence if found in the search functions (binary or linear search functions) of the array
 * implement and provide a non copy iterative quick sort implementation (using stack of unsigned int for upper and lower bound) for the part of the array

 * implement a node based binomial heap and fibonacci heap (implement them as an embedded node based data structure like linked_list and bst, such that this embedded node consists of leftmost_child, parent and right_sibling pointers only), rename heap to binary heap
 * build an abstraction layer over all the three heaps and name it heap and make all methods available from it

 * provide implementation for splay trees in bst
 * convert int in node_property to an unsigned int
 * implement and provide a method for is_bst_empty for bst, replacing the is_balancedbst_empty macro
 * point parent of root node of the bst to some thing other than null to identify a new_node from a single node bst root node

 * encapsulate all macro params with ()

 * provide implementation for singly linked list also, and rename the linkedlist to doubly circular linked list, provide a single linkedlist interface to access both the linked list just like heap
 * ll_node must be a union of sll_node and dcll_node
 * use singly linked list to replace linked lists used in hashmap and binomial/fibonacci heap implementation

 * implement dstring_get_char function returning a character at a given index
 * provide an ability to store the dstring on the stack itself when the strlen(string) < sizeof(dstring) i.e. use dstring as a union of char[] and dstring (current definition)

 * implement and add a stream buffer interface that acts as a queue of strings or serialized objects, this can be used for implementation of network stacks, server request response buffering, parsers and compression algorithms

 * implement a redix tree data structure i.e. a trie data structure that is defined as
struct trie_node
{
	dstring partial_string;
	int prefix_count; // total number of strings in the complete trie structure that have the prefic ending at partial string
	void* value;
	hashmap children; <K,V> => <trie_node.partial_string[0],trie_node>;
};
 * implement insert, search and remove operation to be noted a trie_node can not be deleted as long as it has either of value or any of the children

 * provide an ability to store the dstring on the stack itself when the strlen(string) < sizeof(dstring) i.e. use dstring

 * modify hashmap's % function to something of the sort of bitwise operation to speed it instead of hash % N use something like bitwise(x, N) => [0,N) range

 * implement flat_array and flat_map (using robinhood hashing) that use void* to array of structs instead of void** to array of pointers to structs

 * implement rabin krap and boyer moore substring comparison algorithm, use flat map and flat array for its tables, also use rabin krap hash function as summation of (index * string[index]) for all characters of the string to encapsulate position information of the string in the hash.
 * provide a better interface for selecting between all the 4 substring matching algorithms

 * check and re evaluate what all algorithms can be moved to using flat array and flat map for better cache utilization and replace them
 * provide reasons explicitly for all such descissions, do not replace to flat map or flat array while handling user provided structures

 * add remove all functionality for all data structures

 * add functinality to append 2 linkedlists and make the 2nd linked list contain 0 elements
