1. Tasks picked

 * implement index_accessed_interface for dstring and a comparator function for comparing 2 const char ptrs, then add a testcase to quick sort dstring.

VALUE_ARRAYLIST tasks (NEW DATASTRUCTURE)
 * build an only header file #define declarations_for_value_arraylist(value_arraylist_type_name, value_type) and #define definitions_for_value_arraylist(value_arraylist_type, value_type), and providing all functions of arraylist.h
 * struct value_arraylist_type_name
  {
    cy_uint first;            // first element's index
    cy_uint element_count;    // number of elements in the value_arraylist
    cy_uint capacity;         // number of elements that can be accomodated in the value_arraylist
    memory_allocator mem_allocator; // allocator to use
    value_type* data;       // actual data array
  };
 * add comment that this (value_arraylist) is suppossed to be used with only small ephemeral structs and primitive types, that have no immovable attributes like (synchronization primitives like) mutex, conditional variables or semaphores
 * add comment that it can only be used with quick_sort, bubble_sort and insertion_sort functions (and all other search functions), even though it is index_accessible
 * implement
   * arraylist like functionality - push_front, push_back, pop_front, pop_back, get_front, get_back, get_from_front (, get), get_from_back, set_from_front (, set), set_from_back, swap_from_front (, swap), swap_from_back, insert_from_front (using index_accessed_interface), insert_from_back (using index_accessed_interface), remove_from_front and remove_from_back.
   * get_slice_from_front and get_slice_from_back to return value_arraylist_type_name
   * heap like functionality - (utility static bubble_up and bubble_down functions) push_heap, pop_heap, top_heap, heapify (takes compare function and degree of heap as input)
   * implement getter for index_accessed_interface
   * copy functionality for radix_sort, heap_sort (using a cut slice of value_arraylist), (iterative like existing) merge_sort, all other sorts and search functions can be reused

2. Add new datastructure types tasks (*future)

RADIX_TREE tasks (NEW DATASTRUCTURE)
 * implement a radix tree data structure i.e. a trie data structure that is defined as
struct trie_node
{
    dstring partial_string;
    cy_uint prefix_count; // total number of strings in the complete trie data structure that have the prefix of partial_string
    void* value;
    hashmap children; <K,V> => <trie_node.partial_string[0],trie_node>;

    // node for children hashmap, used by the parent, this will only be ununsed in root trie_node
    rbhnode/bstnode/llnode children_embed_node;
};
 * implement insert, search and remove operation to be noted a trie_node can not be deleted as long as it has either of value or any of the children

HEAP tasks (NEW DATASTRUCTURE inclusion)
 * implement a node based binomial heap and fibonacci heap.
 * it will use binomialheap node as a struct
struct binomialheapnode
{
	// parent of this node
	binomialheapnode* parent;

	// number of children
	cy_uint degree;

	// linkedlist of its children
	linkedlist children;
};
 * binomialheapnode will have utility functions to detach-from-parent, swap position-with-parent, link-parent-and-child etc since these fucntions can be used both with fibonacci heap and binomial heap
 * we will also have the main data structure struct as
struct binomialheap
{
	// implementation_type can be FIBONACCI_FAST_HEAP or BINOMIAL_FAST_HEAP
	binomialheap_implementation_type implementation_type;

	// type stores MIN_HEAP or MAX_HEAP
	heap_type type;

	// pointer to the least or greatest node, based on type
	binomialheapnode* top_node;

	linkedlist root_list;

	// comparator
	int (*compare)(const void* data1, const void* data2);
};

 * implement leftist heap as leftistheap (* future)

DSTRING tasks
 * implement boyer moore substring finding algorithm (and Aho corasick algorithm)

BST tasks (NEW DATASTRUCTURE inclusion * future)
 * provide implementation for TREAP, AA_TREE etc in bst
 * add cy_uint subtree_size (==0 if node is not in any bst) giving the number of nodes in sub tree rooted at the given node 
   * to provide functionality to get_index_of_element_in_bst, get_element_at_index_in_bst OR get_element_count in bst and get_subtree_element_count (internal function).
   * changes only required to subtree_size in bst_rotations.* and bst_core.* source files.

3. Competely new datastructure tasks (*future)

RANGE QUERY ON INT/UINT ARRAY DATASTRUCTURE tasks
 * use value_arraylist for below functionality and implement their itrative approaches only
 * access methods must be insert, update, find_range
 * implement segment tree => for min, max, sum, product(multiplication), bitwise-and, bitwise-or, bitwise-xor, lcm and hcf
 * implement fenwick tree => for addition, product(multiplication), bitwise-xor => the functions for which their inverse exists
 * implement sparse table => max, min, lcm, hcf => the functions for which f(a,b,c,d,e) = f(f(a,b,c), f(b,c,d,e))
